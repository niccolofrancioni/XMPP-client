/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package client;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.security.Security;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

import javax.crypto.Cipher;

import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.jivesoftware.smack.AbstractXMPPConnection;
import org.jivesoftware.smack.SmackException;
import org.jivesoftware.smack.XMPPException;
import org.jivesoftware.smack.chat2.Chat;
import org.jivesoftware.smack.chat2.ChatManager;
import org.jivesoftware.smack.packet.Message;
import org.jivesoftware.smack.packet.Presence;
import org.jivesoftware.smack.packet.Stanza;
import org.jivesoftware.smack.roster.Roster;
import org.jivesoftware.smack.roster.RosterEntry;
import org.jivesoftware.smack.tcp.XMPPTCPConnection;
import org.jivesoftware.smackx.carbons.CarbonManager;
import org.jivesoftware.smackx.carbons.packet.CarbonExtension;
import org.jivesoftware.smackx.omemo.OmemoConfiguration;
import org.jivesoftware.smackx.omemo.OmemoManager;
import org.jivesoftware.smackx.omemo.OmemoMessage;
import org.jivesoftware.smackx.omemo.exceptions.UndecidedOmemoIdentityException;
import org.jivesoftware.smackx.omemo.internal.OmemoCachedDeviceList;
import org.jivesoftware.smackx.omemo.internal.OmemoDevice;
import org.jivesoftware.smackx.omemo.listener.OmemoMessageListener;
import org.jivesoftware.smackx.omemo.signal.SignalCachingOmemoStore;
import org.jivesoftware.smackx.omemo.signal.SignalFileBasedOmemoStore;
import org.jivesoftware.smackx.omemo.signal.SignalOmemoService;
import org.jivesoftware.smackx.omemo.trust.OmemoFingerprint;
import org.jivesoftware.smackx.omemo.trust.OmemoTrustCallback;
import org.jivesoftware.smackx.omemo.trust.TrustState;
import org.jxmpp.jid.BareJid;
import org.jxmpp.jid.EntityBareJid;
import org.jxmpp.jid.impl.JidCreate;
import org.jxmpp.stringprep.XmppStringprepException;
import org.whispersystems.libsignal.IdentityKey;

public class App {
	String jidname = null, password = null;
	private AbstractXMPPConnection connection;
	private OmemoManager omemoManager;
	private final static File storePath = new File("store");
	SignalOmemoService service;
	Roster roster;
	Chat current;
	boolean omemo;
	ChatManager cm;

	public static void main(String[] args) {
		App app = new App();
		try {
			app.start();
		} catch (Exception e) {
			e.printStackTrace();
		}

	}

	/*
	 * Handles and executes user command
	 */
	private void handleInput(String input) throws Exception {
		String[] split = input.split(" ");
		String command = split[0];

		switch (command) {

		/*
		 * Send an unencrypted message
		 */
		case "/chat":
			if (split.length > 2) {
				String recipient = split[1];
				EntityBareJid recipientJid = JidCreate.entityBareFrom(recipient);

				StringBuilder message = new StringBuilder(split[2]);
				for (int i = 3; i < split.length; i++)
					message.append(" ").append(split[i]);

				ChatManager.getInstanceFor(connection).chatWith(recipientJid).send(message);
			}
			break;

		/*
		 * Add a contact to the roster
		 */
		case "/add":
			if (split.length > 2) {
				String recipient = split[1];
				EntityBareJid recipientJid = JidCreate.entityBareFrom(recipient);
				roster.createEntry(recipientJid, split[2], new String[] { split[3] });
			}
			break;

		/*
		 * Remove a contact from the roster
		 */
		case "/remove":
			if (split.length == 2) {
				String recipient = split[1];
				EntityBareJid recipientJid = JidCreate.entityBareFrom(recipient);
				roster.removeEntry(roster.getEntry(recipientJid));
				System.out.println("Removed contact from roster");
			}
			break;

		/*
		 * List the contacts roster
		 */
		case "/list":
			if (split.length == 1) {
				for (RosterEntry r : roster.getEntries()) {
					System.out.println(r.getName() + " (" + r.getJid() + ") Can I see? " + r.canSeeHisPresence()
							+ ". Can they see? " + r.canSeeMyPresence() + ". Online? "
							+ roster.getPresence(r.getJid()).isAvailable());
				}

			} else {
				EntityBareJid jid = JidCreate.entityBareFrom(split[1]);
				try {
					List<Presence> presences = roster.getAllPresences(jid);
					for (Presence p : presences) {
						System.out.println(p.getFrom());
					}
				} catch (Exception e) {
				}
				omemoManager.requestDeviceListUpdateFor(jid);
				OmemoCachedDeviceList list = service.getOmemoStoreBackend()
						.loadCachedDeviceList(omemoManager.getOwnDevice(), jid);
				if (list == null) {
					list = new OmemoCachedDeviceList();
				}
				ArrayList<String> fps = new ArrayList<>();
				for (int id : list.getActiveDevices()) {
					OmemoDevice d = new OmemoDevice(jid, id);
					IdentityKey idk = service.getOmemoStoreBackend().loadOmemoIdentityKey(omemoManager.getOwnDevice(),
							d);
					if (idk == null) {
						System.out.println("No identityKey for " + d);
					} else {
						OmemoFingerprint fp = service.getOmemoStoreBackend().getFingerprint(omemoManager.getOwnDevice(),
								d);
						if (fp != null) {
							fps.add(fp.blocksOf8Chars());
						}
					}
				}
				for (int i = 0; i < fps.size(); i++) {
					System.out.println(i + ": " + fps.get(i));
				}
			}
			break;

		/*
		 * Trust a device's fingerprints
		 */
		case "/trust":
			if (split.length == 2) {
				System.out.println("Usage: \n0: Untrusted, 1: Trusted, otherwise: Undecided");
				EntityBareJid jid = JidCreate.entityBareFrom(split[1]);

				if (jid == null) {
					break;
				}

				System.out.println(jid);

				omemoManager.requestDeviceListUpdateFor(jid);

				for (OmemoDevice device : omemoManager.getDevicesOf(jid)) {
					OmemoFingerprint fp = omemoManager.getFingerprint(device);

					if (omemoManager.isDecidedOmemoIdentity(device, fp)) {
						if (omemoManager.isTrustedOmemoIdentity(device, fp)) {
							System.out.println("Status: Trusted");
						} else {
							System.out.println("Status: Untrusted");
						}
					} else {
						System.out.println("Status: Undecided");
					}

					System.out.println(fp.blocksOf8Chars());
					Scanner scanner = new Scanner(System.in);
					String decision = scanner.nextLine();
					if (decision.equals("0")) {
						omemoManager.distrustOmemoIdentity(device, fp);
						System.out.println("Identity has been untrusted.");
					} else if (decision.equals("1")) {
						omemoManager.trustOmemoIdentity(device, fp);
						System.out.println("Identity has been trusted.");
					}
				}
			}
			break;

		/*
		 * Remove all other devices from the list of active devices
		 */
		case "/purge":
			if (split.length == 1) {
				omemoManager.purgeDeviceList();
				System.out.println("Purge successful.");
			}
			break;

		/*
		 * Send an encrypted message
		 */
		case "/omemo":
			if (split.length > 2) {
				EntityBareJid recipient = JidCreate.entityBareFrom(split[1]);
				if (recipient != null) {
					String message = "";
					for (int i = 2; i < split.length; i++) {
						message += split[i] + " ";
					}
					OmemoMessage.Sent encrypted = null;
					try {
						// Set a cipher provider
						Security.addProvider(new BouncyCastleProvider());
						Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding", "BC");
						encrypted = omemoManager.encrypt(recipient, message.trim());
					} catch (UndecidedOmemoIdentityException e) {
						System.out.println("There are undecided identities:");
						for (OmemoDevice d : e.getUndecidedDevices()) {
							System.out.println(d.toString());
						}
					}
					if (encrypted != null) {
						current = cm.chatWith(recipient);
						Message m = new Message();
						m.addExtension(encrypted.getElement());
						current.send(m);
						System.out.println("Message sent");
					}
				}
				omemo = true;
			}
			break;

		/*
		 * Show your own fingerprint
		 */
		case "/fingerprint":
			if (split.length == 1) {
				OmemoFingerprint fingerprint = omemoManager.getOwnFingerprint();
				System.out.println(fingerprint.blocksOf8Chars());
			}
			break;

		/*
		 * Send a ratchet message to rebuild a session with a contact
		 */
		case "/ratchetUpdate":
			if (split.length == 2) {
				EntityBareJid recipient = JidCreate.entityBareFrom(split[1]);
				OmemoCachedDeviceList cachedDeviceList = service.getOmemoStoreBackend()
						.loadCachedDeviceList(omemoManager.getOwnDevice(), recipient);
				for (int id : cachedDeviceList.getActiveDevices()) {
					OmemoDevice d = new OmemoDevice(recipient, id);
					omemoManager.sendRatchetUpdateMessage(d);
				}
			}
		}

	}

	private void printMenu() {
		System.out.println("\n \n/chat <Jid> <Message>: Send a normal unencrypted chat message to a user. \n"
				+ "/omemo <Jid> <Message>: Send an encrypted chat message to a user. \n" + "/list: List your roster. \n"
				+ "/add <Jid> <Nickname> <group>: Add a new contact to your roster. \n"
				+ "/remove <Jid>: Remove a contact from your roster. \n" + "/quit: Quit the application. \n"
				+ "/trust <Jid>: trust user. \n"
				+ "/purge: Remove all other devices from your list of active devices.\n"
				+ "/fingerprint: Show your OMEMO fingerprint. \n"
				+ "/ratchetUpdate <Jid>: send ratchet message to repair the session with a contact. \n \n");

	}

	private void start() throws Exception {

		Scanner scanner = new Scanner(System.in);
		while (jidname == null) {
			System.out.println("Enter username:");
			jidname = scanner.nextLine();
		}
		while (password == null) {
			System.out.println("Enter password:");
			password = PasswordField.readPassword();
		}
		connection = new XMPPTCPConnection(jidname, password);

		this.setupOmemo();

		while (true) {
			this.printMenu();
			String input = scanner.nextLine();

			if (input.startsWith("/quit")) {
				connection.disconnect();
				break;
			}
			if (input.isEmpty()) {
				continue;
			}
			try {
				this.handleInput(input);
			} catch (Exception e) {

				e.printStackTrace();
			}
		}
	}

	private void setupOmemo() throws Exception {
		SignalOmemoService.acknowledgeLicense();
		SignalOmemoService.setup();
		service = (SignalOmemoService) SignalOmemoService.getInstance();
		service.setOmemoStoreBackend(new SignalCachingOmemoStore(new SignalFileBasedOmemoStore(storePath)));
		OmemoConfiguration.setAddOmemoHintBody(false);
		omemoManager = OmemoManager.getInstanceFor(connection);
		omemoManager.setTrustCallback(new OmemoTrustCallback() {
			@Override
			public TrustState getTrust(OmemoDevice device, OmemoFingerprint fingerprint) {
				try {
					return App.this.getTrust(omemoManager.getOwnDevice(), device, fingerprint);
				} catch (IOException e) {
					System.out.println("Could not get Trust of device " + device.toString() + ": " + e.getMessage());
					return TrustState.undecided;
				}
			}

			@Override
			public void setTrust(OmemoDevice device, OmemoFingerprint fingerprint, TrustState state) {
				try {
					App.this.storeTrust(omemoManager.getOwnDevice(), device, fingerprint, state);
				} catch (IOException e) {
					System.out.println("Could not set Trust of device " + device.toString() + ": " + e.getMessage());
				}
			}
		});

		connection.setReplyTimeout(10000);
		connection = connection.connect();
		connection.login();
		omemoManager.initialize();

		/*
		 * Create a listener for encrypted incoming messages
		 */
		OmemoMessageListener messageListener = new OmemoMessageListener() {
			@Override
			public void onOmemoMessageReceived(Stanza stanza, OmemoMessage.Received received) {
				BareJid sender = stanza.getFrom().asBareJid();
				if (received.isKeyTransportMessage()) {
					return;
				}
				String decryptedBody = received.getBody();
				if (sender != null && decryptedBody != null) {
					OmemoConfiguration.setAddOmemoHintBody(false);
					System.out.println(sender.toString());
					System.out.println(decryptedBody);
				}
			}

			@Override
			public void onOmemoCarbonCopyReceived(CarbonExtension.Direction direction, Message carbonCopy,
					Message wrappingMessage, OmemoMessage.Received decryptedCarbonCopy) {

			}
		};

		// Carbon Copies
		CarbonManager.getInstanceFor(connection).enableCarbons();
		omemoManager.addOmemoMessageListener(messageListener);

		// Contact list
		roster = Roster.getInstanceFor(connection);
		roster.setSubscriptionMode(Roster.SubscriptionMode.accept_all);

		/*
		 * Single chat Create a listener for incoming messages
		 */
		cm = ChatManager.getInstanceFor(connection);
		cm.addIncomingListener(
				(from, message, chat) -> System.out.println(from.asBareJid() + ": " + message.getBody()));

		System.out.println("OMEMO setup complete. You can now start chatting.");
		current = null;
		omemo = false;
	}

	/*
	 * Store on a local file trusted devices' fingerprints
	 */
	protected void storeTrust(OmemoDevice userDevice, OmemoDevice contactsDevice, OmemoFingerprint fingerprint,
			TrustState trustState) throws IOException {

		File target = new File(storePath,
				"OMEMO_Store" + File.separator + userDevice.getJid().toString() + File.separator
						+ userDevice.getDeviceId() + File.separator + "contacts" + File.separator
						+ contactsDevice.getJid().toString() + File.separator + contactsDevice.getDeviceId()
						+ File.separator + "trust");
		if (!target.exists()) {
			target.getParentFile().mkdirs();
			target.createNewFile();
		}

		try (PrintWriter out = new PrintWriter(target)) {
			out.write(fingerprint.toString() + " " + trustState);
		} catch (FileNotFoundException e) {
			throw new AssertionError(e);
		}

	}

	/*
	 * Retrieve the file with the trusted devices' fingerprints
	 */
	protected TrustState getTrust(OmemoDevice userDevice, OmemoDevice contactsDevice, OmemoFingerprint fingerprint)
			throws IOException {
		File target = new File(storePath,
				"OMEMO_Store" + File.separator + userDevice.getJid().toString() + File.separator
						+ userDevice.getDeviceId() + File.separator + "contacts" + File.separator
						+ contactsDevice.getJid().toString() + File.separator + contactsDevice.getDeviceId()
						+ File.separator + "trust");

		if (!target.exists()) {
			return TrustState.undecided;
		}

		try (BufferedReader in = new BufferedReader(new FileReader(target))) {
			String line = in.readLine();
			String[] split = line.split(" ");
			if (split.length != 2) {
				return TrustState.undecided;
			}
			OmemoFingerprint f = new OmemoFingerprint(split[0]);
			TrustState t = TrustState.valueOf(split[1]);
			if (f.equals(fingerprint)) {
				return t;
			}
			return TrustState.untrusted;
		} catch (FileNotFoundException e) {
			throw new AssertionError(e);
		}

	}

}
